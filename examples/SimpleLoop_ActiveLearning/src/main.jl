import BSON
import NonLinearSystemNeuralNetworkFMU

function mymain(modelName::String, N::Integer; reuseArtifacts=true::Bool, pretrain=0.1)
  moFiles = [srcdir("$modelName.mo")]

  omOptions = OMOptions(
    workingDir=datadir("sims", "$(modelName)_$(N)_$(pretrain)"),
    clean=false,
    commandLineOptions="--preOptModules-=wrapFunctionCalls --postOptModules-=wrapFunctionCalls"
  )

  dataGenOptions = DataGenOptions(;
    method=RandomMethod(),
    n=round(Integer, N*pretrain),
    nBatches=1,
    nThreads=Threads.nthreads(),
    append=false,
    clean=true
  )

  (csvFiles, _, profilingInfo) = NonLinearSystemNeuralNetworkFMU.main(modelName, moFiles; omOptions=omOptions, dataGenOptions=dataGenOptions, reuseArtifacts=reuseArtifacts)

  csvFilesReverse = reverse(csvFiles)

  fmu_interface = joinpath(omOptions.workingDir, modelName * ".interface.fmu")
  @assert isfile(fmu_interface) "no file '*.interface.fmu' found"


  alOptions = ActiveLearnOptions(; samples=N-dataGenOptions.n)

  # Train models
  @info "Train models"
  onnxFiles = String[]
  for prof in profilingInfo
    eqIndex = prof.eqInfo.id
    inputVars = prof.usingVars
    outputVars = prof.iterationVariables
    minBoundary = prof.boundary.min
    maxBoundary = prof.boundary.max

    onnxFile = abspath(joinpath(omOptions.workingDir, "onnx", "eq_$(prof.eqInfo.id).onnx"))
    local model
    if reuseArtifacts && isfile(onnxFile * ".bson")
      @info "Reusing $(onnxFile).bson"
      BSON.@load onnxFile * ".bson" model
    else
      # build surrogate model
      nInputs = length(inputVars) + length(outputVars)
      nOutputs = length(outputVars)
      model = Flux.Chain(
        Flux.Dense(nInputs, nInputs * 10, Flux.Ïƒ),
        Flux.Dense(nInputs * 10, nOutputs * 10, tanh),
        Flux.Dense(nOutputs * 10, nOutputs)
      )
    end
    @info "Surrogate has $(sum(length, Flux.params(model))) params"
    @assert sum(length, Flux.params(model)) < N "too few data points"

    # Data generated by AL is saved as CSV so we can see where the surrogate was trained
    #csvFile = abspath(joinpath(omOptions.workingDir, "data", "eq_$(prof.eqInfo.id).csv"))
    csvFile = pop!(csvFilesReverse)
    @assert csvFile == abspath(joinpath(omOptions.workingDir, "data", "eq_$(prof.eqInfo.id).csv")) "filename wrong"
    @assert isfile(csvFile) "csvFile does not exist"

    activeLearnWrapper(fmu_interface, csvFile, model, onnxFile, csvFile, eqIndex, inputVars, minBoundary, maxBoundary, outputVars; options=alOptions)
    push!(onnxFiles, onnxFile)
  end
  if omOptions.clean
    rm(tempDir, force=true, recursive=true)
  end

  fmu_onnx = buildWithOnnx(
    fmu_interface,
    modelName,
    profilingInfo,
    onnxFiles;
    tempDir=omOptions.workingDir,
    usePrevSol=true
  )

  simulateFMU(modelName, N, omOptions.workingDir)
end
